{"ast":null,"code":"/**\r\n * The resolvers are the responsible of translating the routes to components\r\n * letting react-tiles know what to display when a route is received.\r\n *\r\n * A resolver is just an object with three methods:\r\n * * init: Called when the react tiles component is mounted, it receives the same props\r\n * \t\t\tfrom it as an argument. It is used to initialize any variables needed by our\r\n * \t\t\tresolver.\r\n *\r\n *  * navigate: Called by react-tile's links to update the current's browser URL and\r\n *  \t\tnavigate to the next screen.\r\n *\r\n *  * resolve: Translates the routes to react components. This method is asynchronous\r\n *  \t\tbecause react-router matching method is asynchronous. Since react-router is the\r\n *  \t\tmost used solution, it forces this method to be this way.\r\n */\nvar Router = require('react-router');\n\nvar history, routes;\nmodule.exports = {\n  init: function (props) {\n    // Store the history and routes objects to be used in the resolve method.\n    // they are private variables.\n    history = props.history;\n    routes = props.routes;\n  },\n  navigate: function (path) {\n    // Uses the history object to navigate.\n    // Any other library may handle the navigation just updating the location\n    // like:\n    // location.href = path;\n    history.push(path);\n  },\n  resolve: function (path, callback) {\n    Router.match({\n      routes: routes,\n      location: path\n    }, function (err, redirect, state) {\n      // We return the second level route's component, since the Tiles component\n      // is used in the first lever route. Your app may update this function to\n      // make route matching working ok.\n      callback(state.routes[1].component);\n    });\n  }\n};","map":{"version":3,"sources":["D:/dreamproject/AppGenerator/public/reactStarter/client/node_modules/react-tiles/src/react-router-resolver.js"],"names":["Router","require","history","routes","module","exports","init","props","navigate","path","push","resolve","callback","match","location","err","redirect","state","component"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAApB;;AAEA,IAAIC,OAAJ,EACEC,MADF;AAIAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,IAAI,EAAE,UAAUC,KAAV,EAAiB;AAErB;AACA;AACAL,IAAAA,OAAO,GAAGK,KAAK,CAACL,OAAhB;AACAC,IAAAA,MAAM,GAAGI,KAAK,CAACJ,MAAf;AACD,GAPc;AAQfK,EAAAA,QAAQ,EAAE,UAAUC,IAAV,EAAgB;AAExB;AACA;AACA;AACA;AACAP,IAAAA,OAAO,CAACQ,IAAR,CAAcD,IAAd;AACD,GAfc;AAgBfE,EAAAA,OAAO,EAAE,UAAUF,IAAV,EAAgBG,QAAhB,EAA0B;AACjCZ,IAAAA,MAAM,CAACa,KAAP,CAAa;AAAEV,MAAAA,MAAM,EAAEA,MAAV;AAAkBW,MAAAA,QAAQ,EAAEL;AAA5B,KAAb,EAAgD,UAAUM,GAAV,EAAeC,QAAf,EAAyBC,KAAzB,EAAgC;AAE9E;AACA;AACA;AACAL,MAAAA,QAAQ,CAAEK,KAAK,CAACd,MAAN,CAAa,CAAb,EAAgBe,SAAlB,CAAR;AACD,KAND;AAOD;AAxBc,CAAjB","sourcesContent":["/**\r\n * The resolvers are the responsible of translating the routes to components\r\n * letting react-tiles know what to display when a route is received.\r\n *\r\n * A resolver is just an object with three methods:\r\n * * init: Called when the react tiles component is mounted, it receives the same props\r\n * \t\t\tfrom it as an argument. It is used to initialize any variables needed by our\r\n * \t\t\tresolver.\r\n *\r\n *  * navigate: Called by react-tile's links to update the current's browser URL and\r\n *  \t\tnavigate to the next screen.\r\n *\r\n *  * resolve: Translates the routes to react components. This method is asynchronous\r\n *  \t\tbecause react-router matching method is asynchronous. Since react-router is the\r\n *  \t\tmost used solution, it forces this method to be this way.\r\n */\r\n\r\nvar Router = require('react-router');\r\n\r\nvar history,\r\n  routes\r\n;\r\n\r\nmodule.exports = {\r\n  init: function( props ){\r\n\r\n    // Store the history and routes objects to be used in the resolve method.\r\n    // they are private variables.\r\n    history = props.history;\r\n    routes = props.routes;\r\n  },\r\n  navigate: function( path ){\r\n\r\n    // Uses the history object to navigate.\r\n    // Any other library may handle the navigation just updating the location\r\n    // like:\r\n    // location.href = path;\r\n    history.push( path );\r\n  },\r\n  resolve: function( path, callback ){\r\n    Router.match({ routes: routes, location: path}, function( err, redirect, state ){\r\n\r\n      // We return the second level route's component, since the Tiles component\r\n      // is used in the first lever route. Your app may update this function to\r\n      // make route matching working ok.\r\n      callback( state.routes[1].component );\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}